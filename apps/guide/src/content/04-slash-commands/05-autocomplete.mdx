---
title: Autocomplete
category: Slash commands
---

# Autocomplete

Autocomplete allows you to dynamically provide a selection of values to the user, based on their input, rather than relying on static choices. In this section we will cover how to add autocomplete support to your commands.

<Alert title="Read first!" type="info">
	This page is a follow-up to the [slash commands](./advanced-command-creation) section covering options and option
	choices, and assumes you have also implemented [event handling](../creating-your-bot/event-handling). Please carefully
	read those pages first so that you can understand the methods used in this section.
</Alert>

## Enabling autocomplete

To use autocomplete with your commands, _instead_ of listing static choices, the option must be set to use autocompletion. This is done by setting _`autocomplete: true`_ in the <DocsLink type="typedef" parent="ApplicationCommandOptionData" />. Autocomplete can be used on the same option types that support static choices; _`String`_, _`Integer`_, and _`Number`_.

<CH.Code>

```js mark=11
import { ApplicationCommandOptionType } from 'discord.js';

export const data = {
	name: 'guide',
	description: 'Search discordjs.guide!',
	options: [
		{
			name: 'query',
			type: ApplicationCommandOptionType.String,
			description: 'Phrase to search for',
			autocomplete: true,
		},
	],
};
```

</CH.Code>

## Responding to autocomplete interactions

To handle an <DocsLink type="class" parent="AutocompleteInteraction"/>, use the <DocsLink type="class" parent="BaseInteraction" symbol="isAutocomplete" brackets /> type guard to make sure the interaction instance is an autocomplete interaction.

You can do this in a separate <DocsLink type="class" parent="Client" symbol="e-interactionCreate" /> file, such as `events/autocompleteInteractionCreate.js`:

<CH.Code>

```js
import { Events } from 'discord.js';

export const data = {
	name: Events.InteractionCreate,
};

export async function execute(interaction) {
	if (!interaction.isAutocomplete()) return;
	// do autocomplete handling
}
```

</CH.Code>

Or alternatively, by making a small change to your existing [Command handler](../creating-your-bot/handling-command-interactions) and adding an additional method to your individual command files.

The example below shows how this might be applied to a conceptual version of the `guide` command to determine the closest topic to the search input:

<CH.Code>

```js events/interactionCreate.js mark=10,19
import { Events } from 'discord.js';

export const data = {
	name: Events.InteractionCreate,
};

export async function execute(interaction) {
	if (interaction.isChatInputCommand()) {
		// command handling
	} else if (interaction.isAutocomplete()) {
		const command = interaction.client.commands.get(interaction.commandName);

		if (!command) {
			console.error(`No command matching ${interaction.commandName} was found.`);
			return;
		}

		try {
			await command.autocomplete(interaction);
		} catch (error) {
			console.error(error);
		}
	}
}
```

```js commands/guide.js mark=16:18
import { ApplicationCommandOptionType } from 'discord.js';

export const data = {
	name: 'guide',
	description: 'Search discordjs.guide!',
	options: [
		{
			name: 'query',
			type: ApplicationCommandOptionType.String,
			description: 'Phrase to search for',
			autocomplete: true,
		},
	],
};

export async function autocomplete(interaction) {
	// handle the autocompletion response (more on how to do that below)
}

export async function execute(interaction) {
	// respond to the complete slash command
}
```

</CH.Code>

The handling for an autocomplete interaction is almost identical, but notice the change from `execute` to `autocomplete` in the new else-if branch. By exporting a separate `autocomplete` function from commands that require autocompletion, you can safely separate the logic of providing dynamic choices from the code that needs to respond to the slash command once it is complete.

### Sending results

The <DocsLink type="class" parent="AutocompleteInteraction" /> class provides the <DocsLink type="class" parent="AutocompleteInteraction" symbol="respond" brackets /> method to send a response. Using this, you can submit an array of <DocsLink type="typedef" parent="ApplicationCommandOptionChoiceData" /> objects for the user to choose from - the same format you would use for static choices. Passing an empty array will show "No options match your search" for the user.

<Alert title="Warning" type="warning">
	Unlike static choices, autocompletion suggestions are *not* enforced, and users may still enter free text.
</Alert>

The <DocsLink type="class" parent="CommandInteractionOptionResolver" symbol="getFocused" brackets /> method returns the currently focused option's value, which can be used to applying filtering to the choices presented. For example, to only display options starting with the focused value you can use the _`Array#filter()`_ method, then using _`Array#map()`_, transform the array into an array of <DocsLink type="typedef" parent="ApplicationCommandOptionChoiceData" /> objects.

<CH.Code rows={16}>

```js focus=16:29
import { ApplicationCommandOptionType } from 'discord.js';

export const data = {
	name: 'guide',
	description: 'Search discordjs.guide!',
	options: [
		{
			name: 'query',
			type: ApplicationCommandOptionType.String,
			description: 'Phrase to search for',
			autocomplete: true,
		},
	],
};

export async function autocomplete(interaction) {
	const focusedValue = interaction.options.getFocused();
	const choices = [
		'Popular Topics: Threads',
		'Sharding: Getting started',
		'Library: Voice Connections',
		'Interactions: Replying to slash commands',
		'Popular Topics: Embed preview',
	];
	const filtered = choices.filter((choice) => choice.startsWith(focusedValue));
	await interaction.respond(filtered.map((choice) => ({ name: choice, value: choice })));
}

export async function execute(interaction) {
	// respond to the complete slash command
}
```

</CH.Code>

### Handling multiple autocomplete options

To distinguish between multiple options, you can pass `true` into <DocsLink type="class" parent="CommandInteractionOptionResolver" symbol="getFocused" brackets />, which will now return the full focused object including the name of the option, instead of just the value. This allows you to differentiate between multiple options, allowing each to have their own set of suggestions:

<CH.Code rows={23}>

```js focus=19:39
import { ApplicationCommandOptionType } from 'discord.js';

export const data = {
	name: 'guide',
	description: 'Search discordjs.guide!',
	options: [{
		name: 'query',
		type: ApplicationCommandOptionType.String,
		description: 'Phrase to search for',
		autocomplete: true,
	}, {
		name: 'version'
		type: ApplicationCommandOptionType.String,
		description: 'Version to search in',
		autocomplete: true,
	}],
};

export async function autocomplete(interaction) {
	const focusedOption = interaction.options.getFocused(true);
	let choices;

	if (focusedOption.name === 'query') {
		choices = [
			'Popular Topics: Threads',
			'Sharding: Getting started',
			'Library: Voice Connections',
			'Interactions: Replying to slash commands',
			'Popular Topics: Embed preview'
		];
	} else if (focusedOption.name === 'version') {
		choices = ['v9', 'v11', 'v12', 'v13', 'v14'];
	}

	const filtered = choices.filter(choice => choice.startsWith(focusedOption.value));
	await interaction.respond(
		filtered.map(choice => ({ name: choice, value: choice })),
	);
};

export async function execute(interaction) {
	// respond to the complete slash command
}
```

</CH.Code>

### Accessing other values

In addition to filtering based on the focused value, you may also wish to change the choices displayed based on the value of other arguments in the command. The following methods work the same in <DocsLink type="class" parent="AutocompleteInteraction" />:

<CH.Code lineNumbers={false}>

```js
const string = interaction.options.getString('input');
const integer = interaction.options.getInteger('int');
const boolean = interaction.options.getBoolean('choice');
const number = interaction.options.getNumber('num');
```

</CH.Code>

However, the _`.getUser()`_, _`.getMember()`_, _`.getRole()`_, _`.getChannel()`_, _`.getMentionable()`_ and _`.getAttachment()`_ methods are not available to autocomplete interactions. Discord does not send the respective full objects for these methods until the slash command is completed. For these, you can get the Snowflake value using _`interaction.options.get('option').value`_:

### Notes

- As with other application command interactions, autocomplete interactions must receive a response within 3 seconds.
- You cannot defer the response to an autocomplete interaction. If you're dealing with asynchronous suggestions, such as from an API, consider keeping a local cache.
- After the user selects a value and sends the command, it will be received as a regular <DocsLink type="class" parent="ChatInputCommandInteraction" /> with the chosen value.
- You can only respond with a maximum of 25 choices at a time, though any more than this likely means you should revise your filter to further narrow the selections.
